Week 5: File Handling and Exception Management
üìã Learning Objectives
By the end of this week, you will be able to:

‚úÖ Read from and write to files in various formats

‚úÖ Handle exceptions gracefully to prevent crashes

‚úÖ Work with JSON data for configuration and storage

‚úÖ Process CSV files for data analysis

‚úÖ Use context managers (with statement) for resource management

‚úÖ Create custom exception classes

‚úÖ Implement logging for debugging and monitoring

‚úÖ Work with binary files and different encodings

üìö Theory Content

5.1 File Formats Comparison

Format	   |       Use Case	              |      Pros	                   |   Cons

TXT	       |       Simple text	          |      Universal,            |       simple	No structure

CSV	       |       Tabular data	          |      Excel compatible,small	 |     Limited data types

JSON	     |       Configuration, APIs	  |      Human-readable, nested	|      Verbose

XML	       |       Legacy systems	        |      Schema validation	       |   Verbose, complex

YAML	     |       Configuration	        |      Very readable	         |     Whitespace sensitive

Binary	   |       Performance	          |      Compact, fast	         |     Not human-readable

üîß Practical Exercises

Exercise 1: Basic File Operations
  # file_basics.py
  """
  Basic file reading and writing operations
  """
  
  print("="*60)
  print("BASIC FILE OPERATIONS")
  print("="*60)
  
  import os
  
  # 1. Writing to a file
  print("\n1. WRITING TO A FILE:")
  print("-"*40)
  
  # Using write() method
  with open("sample.txt", "w") as file:
      file.write("Hello, World!\n")
      file.write("This is line 2.\n")
      file.write("This is line 3.\n")
  print("‚úÖ File 'sample.txt' created and written")
  
  # Writing multiple lines
  lines = ["First line", "Second line", "Third line", "Fourth line"]
  with open("multiple.txt", "w") as file:
      for line in lines:
          file.write(line + "\n")
  print("‚úÖ File 'multiple.txt' created with multiple lines")
  
  # 2. Reading from a file
  print("\n2. READING FROM A FILE:")
  print("-"*40)
  
  # Read entire file
  with open("sample.txt", "r") as file:
      content = file.read()
      print("Full content:")
      print(content)
  
  # Read line by line
  print("\nReading line by line:")
  with open("sample.txt", "r") as file:
      for line in file:
          print(f"  Line: {line.strip()}")
  
  # Read all lines into list
  with open("multiple.txt", "r") as file:
      lines = file.readlines()
      print(f"\nLines as list: {lines}")
      print(f"Number of lines: {len(lines)}")
  
  # 3. Appending to a file
  print("\n3. APPENDING TO A FILE:")
  print("-"*40)
  
  with open("sample.txt", "a") as file:
      file.write("This line is appended.\n")
      file.write("Another appended line.\n")
  print("‚úÖ Content appended to 'sample.txt'")
  
  # Verify append worked
  with open("sample.txt", "r") as file:
      print("Updated content:")
      print(file.read())
  
  # 4. File modes demonstration
  print("\n4. FILE MODES:")
  print("-"*40)
  
  # 'r' - read (default)
  try:
      with open("nonexistent.txt", "r") as file:
          content = file.read()
  except FileNotFoundError as e:
      print(f"'r' mode: File not found error - {e}")
  
  # 'w' - write (creates new or truncates)
  with open("new_file.txt", "w") as file:
      file.write("This file was created with 'w' mode")
  print("'w' mode: Created new_file.txt")
  
  # 'x' - exclusive creation (fails if exists)
  try:
      with open("new_file.txt", "x") as file:
          file.write("This will fail")
  except FileExistsError as e:
      print(f"'x' mode: File exists error - {e}")
  
  # 'a' - append
  with open("new_file.txt", "a") as file:
      file.write("\nThis line was appended")
  print("'a' mode: Appended to new_file.txt")
  
  # 'r+' - read and write
  with open("new_file.txt", "r+") as file:
      content = file.read()
      file.seek(0)  # Go back to beginning
      file.write("MODIFIED: " + content)
  print("'r+' mode: Read and modified file")
  
  # 5. File positioning
  print("\n5. FILE POSITIONING (seek/tell):")
  print("-"*40)
  
  with open("sample.txt", "r") as file:
      print(f"Initial position: {file.tell()}")
      
      content = file.read(10)
      print(f"Read 10 chars: '{content}'")
      print(f"Position after read: {file.tell()}")
      
      file.seek(0)
      print(f"After seek(0): {file.tell()}")
      
      file.seek(5)
      print(f"After seek(5): {file.tell()}")
      content = file.read(5)
      print(f"Read from position 5: '{content}'")
  
  # 6. Working with file paths
  print("\n6. FILE PATHS:")
  print("-"*40)
  
  import os.path
  
  # Get current directory
  current_dir = os.getcwd()
  print(f"Current directory: {current_dir}")
  
  # Join paths
  file_path = os.path.join(current_dir, "sample.txt")
  print(f"Full path: {file_path}")
  
  # Check if file exists
  print(f"File exists: {os.path.exists('sample.txt')}")
  print(f"Is file: {os.path.isfile('sample.txt')}")
  print(f"Is directory: {os.path.isdir('sample.txt')}")
  
  # File info
  file_size = os.path.getsize("sample.txt")
  print(f"File size: {file_size} bytes")
  print(f"Last modified: {os.path.getmtime('sample.txt')}")
  
  # 7. Working with directories
  print("\n7. DIRECTORY OPERATIONS:")
  print("-"*40)
  
  # Create directory
  os.makedirs("test_dir/sub_dir", exist_ok=True)
  print("‚úÖ Created test_dir/sub_dir")
  
  # List directory contents
  print("\nFiles in current directory:")
  for item in os.listdir("."):
      if os.path.isfile(item):
          print(f"  üìÑ {item}")
      elif os.path.isdir(item):
          print(f"  üìÅ {item}/")
  
  # Walk through directory tree
  print("\nDirectory tree:")
  for root, dirs, files in os.walk("test_dir"):
      level = root.count(os.sep)
      indent = "  " * level
      print(f"{indent}üìÅ {os.path.basename(root)}/")
      for file in files:
          print(f"{indent}  üìÑ {file}")
  
  # 8. Temporary files
  print("\n8. TEMPORARY FILES:")
  print("-"*40)
  
  import tempfile
  
  # Create temporary file
  with tempfile.NamedTemporaryFile(mode='w', delete=False) as temp:
      temp.write("Temporary data")
      temp_name = temp.name
      print(f"Created temp file: {temp_name}")
  
  # Read temp file
  with open(temp_name, 'r') as f:
      print(f"Temp file content: {f.read()}")
  
  # Clean up
  os.unlink(temp_name)
  print("Temp file deleted")
  
  # 9. File encoding
  print("\n9. FILE ENCODING:")
  print("-"*40)
  
  # Write with different encoding
  text = "Caf√© M√ºller Âåó‰∫¨ Êù±‰∫¨"
  
  with open("utf8.txt", "w", encoding="utf-8") as f:
      f.write(text)
  print("‚úÖ Written with UTF-8 encoding")
  
  with open("utf16.txt", "w", encoding="utf-16") as f:
      f.write(text)
  print("‚úÖ Written with UTF-16 encoding")
  
  # Read back
  with open("utf8.txt", "r", encoding="utf-8") as f:
      content = f.read()
      print(f"UTF-8 read: {content}")
  
  # 10. Context manager custom class
  print("\n10. CUSTOM CONTEXT MANAGER:")
  print("-"*40)
  
  class FileManager:
      """Custom context manager for file handling"""
      
      def __init__(self, filename, mode):
          self.filename = filename
          self.mode = mode
          self.file = None
      
      def __enter__(self):
          print(f"Opening {self.filename} in {self.mode} mode")
          self.file = open(self.filename, self.mode)
          return self.file
      
      def __exit__(self, exc_type, exc_val, exc_tb):
          print(f"Closing {self.filename}")
          if self.file:
              self.file.close()
          if exc_type:
              print(f"An exception occurred: {exc_val}")
          return True  # Suppress exceptions
  
  # Use custom context manager
  with FileManager("test_custom.txt", "w") as f:
      f.write("Testing custom context manager")
      print("File written")
  
  # Clean up
  print("\nCleaning up test files...")
  for f in ["sample.txt", "multiple.txt", "new_file.txt", "utf8.txt", "utf16.txt", "test_custom.txt"]:
      if os.path.exists(f):
          os.remove(f)
          print(f"Removed {f}")
  
  # Remove test directory
  import shutil
  if os.path.exists("test_dir"):
      shutil.rmtree("test_dir")
      print("Removed test_dir")
Output:

============================================================
BASIC FILE OPERATIONS
============================================================

1. WRITING TO A FILE:
----------------------------------------
‚úÖ File 'sample.txt' created and written
‚úÖ File 'multiple.txt' created with multiple lines

2. READING FROM A FILE:
----------------------------------------
Full content:
Hello, World!
This is line 2.
This is line 3.

Reading line by line:
  Line: Hello, World!
  Line: This is line 2.
  Line: This is line 3.

Lines as list: ['First line\n', 'Second line\n', 'Third line\n', 'Fourth line\n']
Number of lines: 4

3. APPENDING TO A FILE:
----------------------------------------
‚úÖ Content appended to 'sample.txt'
Updated content:
Hello, World!
This is line 2.
This is line 3.
This line is appended.
Another appended line.

4. FILE MODES:
----------------------------------------
'r' mode: File not found error - [Errno 2] No such file or directory: 'nonexistent.txt'
'w' mode: Created new_file.txt
'x' mode: File exists error - [Errno 17] File exists: 'new_file.txt'
'a' mode: Appended to new_file.txt
'r+' mode: Read and modified file

5. FILE POSITIONING (seek/tell):
----------------------------------------
Initial position: 0
Read 10 chars: 'Hello, Wor'
Position after read: 10
After seek(0): 0
After seek(5): 5
Read from position 5: ', Wor'

6. FILE PATHS:
----------------------------------------
Current directory: /home/user/ros2_ws
Full path: /home/user/ros2_ws/sample.txt
File exists: True
Is file: True
Is directory: False
File size: 98 bytes
Last modified: 1705412345.6789

7. DIRECTORY OPERATIONS:
----------------------------------------
‚úÖ Created test_dir/sub_dir

Files in current directory:
  üìÑ file_basics.py
  üìÑ sample.txt
  üìÑ multiple.txt
  üìÑ new_file.txt
  üìÅ test_dir/

Directory tree:
üìÅ test_dir/
  üìÅ sub_dir/

8. TEMPORARY FILES:
----------------------------------------
Created temp file: /tmp/tmpabcdefg
Temp file content: Temporary data
Temp file deleted

9. FILE ENCODING:
----------------------------------------
‚úÖ Written with UTF-8 encoding
‚úÖ Written with UTF-16 encoding
UTF-8 read: Caf√© M√ºller Âåó‰∫¨ Êù±‰∫¨

10. CUSTOM CONTEXT MANAGER:
----------------------------------------
Opening test_custom.txt in w mode
File written
Closing test_custom.txt

Cleaning up test files...
Removed sample.txt
Removed multiple.txt
Removed new_file.txt
Removed utf8.txt
Removed utf16.txt
Removed test_custom.txt
Removed test_dir

Exercise 2: Exception Handling
# exceptions.py
"""
Comprehensive exception handling in Python
"""

print("="*60)
print("EXCEPTION HANDLING")
print("="*60)

# 1. Basic try-except
print("\n1. BASIC TRY-EXCEPT:")
print("-"*40)

try:
    number = int(input("Enter a number: "))
    result = 10 / number
    print(f"10 / {number} = {result}")
except ValueError:
    print("‚ùå That's not a valid number!")
except ZeroDivisionError:
    print("‚ùå Cannot divide by zero!")
except Exception as e:
    print(f"‚ùå An unexpected error occurred: {e}")

# 2. Multiple exceptions in one block
print("\n2. MULTIPLE EXCEPTIONS:")
print("-"*40)

try:
    num = int(input("Enter index: "))
    my_list = [1, 2, 3]
    print(f"Element at index {num}: {my_list[num]}")
except (ValueError, IndexError) as e:
    print(f"‚ùå Error: {e} - Invalid input or index")

# 3. try-except-else
print("\n3. TRY-EXCEPT-ELSE:")
print("-"*40)

try:
    num = int(input("Enter a positive number: "))
    if num <= 0:
        raise ValueError("Number must be positive")
except ValueError as e:
    print(f"‚ùå Error: {e}")
else:
    print(f"‚úÖ Success! You entered {num}")
    print(f"   Square root: {num ** 0.5:.2f}")

# 4. try-except-finally
print("\n4. TRY-EXCEPT-FINALLY:")
print("-"*40)

file = None
try:
    file = open("test_file.txt", "r")
    content = file.read()
    print(f"File content: {content}")
except FileNotFoundError:
    print("‚ùå File not found!")
finally:
    if file:
        file.close()
        print("‚úÖ File closed in finally block")
    print("üîÑ This always executes")

# 5. Raising exceptions
print("\n5. RAISING EXCEPTIONS:")
print("-"*40)

def validate_age(age):
    """Validate age with custom exceptions"""
    if not isinstance(age, (int, float)):
        raise TypeError("Age must be a number")
    if age < 0:
        raise ValueError("Age cannot be negative")
    if age > 150:
        raise ValueError("Age cannot be > 150")
    return True

# Test validation
test_ages = [25, -5, "twenty", 200]
for age in test_ages:
    try:
        validate_age(age)
        print(f"‚úÖ Age {age} is valid")
    except (TypeError, ValueError) as e:
        print(f"‚ùå Age {age}: {e}")

# 6. Custom exception classes
print("\n6. CUSTOM EXCEPTION CLASSES:")
print("-"*40)

class InsufficientFundsError(Exception):
    """Raised when account has insufficient funds"""
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        self.message = f"Insufficient funds: balance ${balance}, tried to withdraw ${amount}"
        super().__init__(self.message)

class NegativeAmountError(Exception):
    """Raised when transaction amount is negative"""
    pass

class AccountClosedError(Exception):
    """Raised when account is closed"""
    pass

class BankAccount:
    """Simple bank account with custom exceptions"""
    
    def __init__(self, owner, initial_balance=0):
        self.owner = owner
        self.balance = initial_balance
        self.closed = False
    
    def withdraw(self, amount):
        """Withdraw money from account"""
        if self.closed:
            raise AccountClosedError(f"Account for {self.owner} is closed")
        
        if amount < 0:
            raise NegativeAmountError("Withdrawal amount cannot be negative")
        
        if amount > self.balance:
            raise InsufficientFundsError(self.balance, amount)
        
        self.balance -= amount
        print(f"‚úÖ Withdrew ${amount}. New balance: ${self.balance}")
    
    def deposit(self, amount):
        """Deposit money to account"""
        if self.closed:
            raise AccountClosedError(f"Account for {self.owner} is closed")
        
        if amount < 0:
            raise NegativeAmountError("Deposit amount cannot be negative")
        
        self.balance += amount
        print(f"‚úÖ Deposited ${amount}. New balance: ${self.balance}")
    
    def close(self):
        """Close the account"""
        self.closed = True
        print(f"‚úÖ Account for {self.owner} closed")

# Test bank account
print("\nTesting BankAccount with custom exceptions:")
account = BankAccount("Alice", 1000)

try:
    account.withdraw(500)
    account.withdraw(700)  # This should fail
except InsufficientFundsError as e:
    print(f"‚ùå {e}")
except NegativeAmountError:
    print("‚ùå Cannot withdraw negative amount")
except AccountClosedError as e:
    print(f"‚ùå {e}")

try:
    account.deposit(-50)  # This should fail
except NegativeAmountError:
    print("‚ùå Cannot deposit negative amount")

# 7. Exception chaining
print("\n7. EXCEPTION CHAINING:")
print("-"*40)

def process_data(filename):
    """Process data with exception chaining"""
    try:
        with open(filename, 'r') as f:
            data = f.read()
            return int(data)
    except FileNotFoundError as e:
        raise ValueError(f"Could not process {filename}") from e

try:
    result = process_data("nonexistent.txt")
except ValueError as e:
    print(f"Error: {e}")
    print(f"Caused by: {e.__cause__}")

# 8. Assertions for debugging
print("\n8. ASSERTIONS:")
print("-"*40)

def calculate_discount(price, discount_percent):
    """Calculate discounted price with assertions"""
    assert price > 0, "Price must be positive"
    assert 0 <= discount_percent <= 100, "Discount must be between 0 and 100"
    
    discount = price * discount_percent / 100
    return price - discount

# Test assertions
test_cases = [(100, 20), (-50, 10), (100, 150)]
for price, discount in test_cases:
    try:
        result = calculate_discount(price, discount)
        print(f"Price ${price}, {discount}% discount: ${result:.2f}")
    except AssertionError as e:
        print(f"‚ùå Assertion failed: {e}")

# 9. Context managers for exception handling
print("\n9. CONTEXT MANAGERS:")
print("-"*40)

class ErrorLogger:
    """Context manager for logging errors"""
    
    def __init__(self, filename):
        self.filename = filename
    
    def __enter__(self):
        self.log_file = open(self.filename, 'a')
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            import datetime
            timestamp = datetime.datetime.now().isoformat()
            self.log_file.write(f"[{timestamp}] {exc_type.__name__}: {exc_val}\n")
            print(f"‚úÖ Error logged to {self.filename}")
        self.log_file.close()
        return True  # Suppress exception

# Use error logger
with ErrorLogger("errors.log") as logger:
    x = 1 / 0  # This will cause ZeroDivisionError

print("Program continues after suppressed exception")

# 10. Best practices
print("\n10. BEST PRACTICES:")
print("-"*40)

print("""
DO:
‚úÖ Be specific with exception types
‚úÖ Use finally for cleanup
‚úÖ Create custom exceptions for application-specific errors
‚úÖ Log exceptions for debugging
‚úÖ Use context managers for resource management

DON'T:
‚ùå Catch bare 'Exception' unless necessary
‚ùå Swallow exceptions silently
‚ùå Use exceptions for flow control
‚ùå Ignore return codes when exceptions are better
‚ùå Raise generic exceptions
""")

# Clean up
if os.path.exists("test_file.txt"):
    os.remove("test_file.txt")
if os.path.exists("errors.log"):
    os.remove("errors.log")

Sample Output:

============================================================
EXCEPTION HANDLING
============================================================

1. BASIC TRY-EXCEPT:
----------------------------------------
Enter a number: 0
‚ùå Cannot divide by zero!

2. MULTIPLE EXCEPTIONS:
----------------------------------------
Enter index: 5
‚ùå Error: list index out of range - Invalid input or index

3. TRY-EXCEPT-ELSE:
----------------------------------------
Enter a positive number: -5
‚ùå Error: Number must be positive

4. TRY-EXCEPT-FINALLY:
----------------------------------------
‚ùå File not found!
üîÑ This always executes

5. RAISING EXCEPTIONS:
----------------------------------------
‚úÖ Age 25 is valid
‚ùå Age -5: Age cannot be negative
‚ùå Age twenty: Age must be a number
‚ùå Age 200: Age cannot be > 150

6. CUSTOM EXCEPTION CLASSES:
----------------------------------------
‚úÖ Withdrew $500. New balance: $500
‚ùå Insufficient funds: balance $500, tried to withdraw $700
‚ùå Cannot deposit negative amount

7. EXCEPTION CHAINING:
----------------------------------------
Error: Could not process nonexistent.txt
Caused by: [Errno 2] No such file or directory: 'nonexistent.txt'

8. ASSERTIONS:
----------------------------------------
Price $100, 20% discount: $80.00
‚ùå Assertion failed: Price must be positive
‚ùå Assertion failed: Discount must be between 0 and 100

9. CONTEXT MANAGERS:
----------------------------------------
‚úÖ Error logged to errors.log
Program continues after suppressed exception

10. BEST PRACTICES:
----------------------------------------
DO:
‚úÖ Be specific with exception types
‚úÖ Use finally for cleanup
‚úÖ Create custom exceptions for application-specific errors
‚úÖ Log exceptions for debugging
‚úÖ Use context managers for resource management

DON'T:
‚ùå Catch bare 'Exception' unless necessary
‚ùå Swallow exceptions silently
‚ùå Use exceptions for flow control
‚ùå Ignore return codes when exceptions are better
‚ùå Raise generic exceptions
Exercise 3: Working with JSON

# json_handling.py
"""
JSON data handling in Python
"""

print("="*60)
print("JSON DATA HANDLING")
print("="*60)

import json
import datetime
from pathlib import Path

# 1. Basic JSON serialization
print("\n1. BASIC JSON SERIALIZATION:")
print("-"*40)

# Python dictionary
data = {
    "name": "Alice",
    "age": 30,
    "city": "New York",
    "hobbies": ["reading", "cycling", "photography"],
    "married": False,
    "salary": 75000.50,
    "projects": None
}

print("Python dictionary:")
print(data)

# Convert to JSON string
json_string = json.dumps(data, indent=2)
print("\nJSON string:")
print(json_string)

# Convert back to Python
parsed_data = json.loads(json_string)
print("\nParsed back to Python:")
print(parsed_data)
print(f"Type after parsing: {type(parsed_data)}")

# 2. Writing JSON to file
print("\n2. WRITING JSON TO FILE:")
print("-"*40)

# Write to file
with open("data.json", "w") as f:
    json.dump(data, f, indent=4)
print("‚úÖ Data written to data.json")

# 3. Reading JSON from file
print("\n3. READING JSON FROM FILE:")
print("-"*40)

with open("data.json", "r") as f:
    loaded_data = json.load(f)
print("‚úÖ Data loaded from data.json")
print(f"Loaded: {loaded_data}")

# 4. Complex data structures
print("\n4. COMPLEX DATA STRUCTURES:")
print("-"*40)

complex_data = {
    "users": [
        {"id": 1, "name": "Alice", "scores": [85, 92, 78]},
        {"id": 2, "name": "Bob", "scores": [90, 88, 95]},
        {"id": 3, "name": "Charlie", "scores": [76, 89, 82]}
    ],
    "metadata": {
        "version": "1.0",
        "last_updated": "2024-01-15",
        "total_users": 3
    },
    "settings": {
        "theme": "dark",
        "notifications": True,
        "language": "en"
    }
}

with open("complex.json", "w") as f:
    json.dump(complex_data, f, indent=2)
print("‚úÖ Complex data saved to complex.json")

# Read and process
with open("complex.json", "r") as f:
    data = json.load(f)
    
print("\nProcessing complex data:")
for user in data["users"]:
    avg_score = sum(user["scores"]) / len(user["scores"])
    print(f"  {user['name']}: average score = {avg_score:.1f}")

# 5. Handling special types
print("\n5. HANDLING SPECIAL TYPES:")
print("-"*40)

class CustomEncoder(json.JSONEncoder):
    """Custom JSON encoder for special types"""
    
    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat()
        if isinstance(obj, datetime.date):
            return obj.isoformat()
        if isinstance(obj, set):
            return list(obj)
        if isinstance(obj, Path):
            return str(obj)
        return super().default(obj)

# Data with special types
special_data = {
    "timestamp": datetime.datetime.now(),
    "date": datetime.date.today(),
    "unique_ids": {1, 2, 3, 4, 5},
    "file_path": Path("/home/user/data.txt"),
    "name": "Special Data"
}

# Serialize with custom encoder
json_str = json.dumps(special_data, cls=CustomEncoder, indent=2)
print("Serialized with custom encoder:")
print(json_str)

# Save to file
with open("special.json", "w") as f:
    json.dump(special_data, f, cls=CustomEncoder, indent=2)
print("‚úÖ Special data saved to special.json")

# 6. Pretty printing
print("\n6. PRETTY PRINTING:")
print("-"*40)

ugly_json = '{"name":"Alice","age":30,"city":"New York","hobbies":["reading","cycling"]}'
print("Ugly JSON:", ugly_json)

# Pretty print
parsed = json.loads(ugly_json)
pretty = json.dumps(parsed, indent=4, sort_keys=True)
print("Pretty printed:")
print(pretty)

# 7. JSON validation
print("\n7. JSON VALIDATION:")
print("-"*40)

def validate_json(json_string):
    """Validate JSON string"""
    try:
        json.loads(json_string)
        return True, "Valid JSON"
    except json.JSONDecodeError as e:
        return False, str(e)

# Test valid JSON
valid_json = '{"name": "Alice", "age": 30}'
is_valid, message = validate_json(valid_json)
print(f"Valid JSON: {is_valid} - {message}")

# Test invalid JSON
invalid_json = '{"name": "Alice", "age": 30,}'  # Trailing comma
is_valid, message = validate_json(invalid_json)
print(f"Invalid JSON: {is_valid} - {message}")

# 8. JSON minify (remove whitespace)
print("\n8. JSON MINIFY:")
print("-"*40)

def minify_json(json_string):
    """Remove unnecessary whitespace from JSON"""
    parsed = json.loads(json_string)
    return json.dumps(parsed, separators=(',', ':'))

verbose_json = """
{
    "name": "Alice",
    "age": 30,
    "city": "New York",
    "hobbies": [
        "reading",
        "cycling"
    ]
}
"""

minified = minify_json(verbose_json)
print("Minified JSON:")
print(minified)
print(f"Length: original={len(verbose_json)}, minified={len(minified)}")

# 9. JSON configuration file example
print("\n9. CONFIGURATION FILE EXAMPLE:")
print("-"*40)

config = {
    "app_name": "Task Manager",
    "version": "2.1.0",
    "debug": False,
    "database": {
        "host": "localhost",
        "port": 5432,
        "name": "taskdb",
        "user": "admin",
        "password": "secret123"
    },
    "logging": {
        "level": "INFO",
        "file": "app.log",
        "max_size": 10485760,
        "backup_count": 5
    },
    "features": {
        "dark_mode": True,
        "notifications": True,
        "auto_save": True,
        "sync_interval": 300
    }
}

# Save config
with open("config.json", "w") as f:
    json.dump(config, f, indent=2)
print("‚úÖ Configuration saved to config.json")

# Load and use config
with open("config.json", "r") as f:
    loaded_config = json.load(f)
    
print("\nConfiguration loaded:")
print(f"App: {loaded_config['app_name']} v{loaded_config['version']}")
print(f"Database: {loaded_config['database']['host']}:{loaded_config['database']['port']}")
print(f"Debug mode: {loaded_config['debug']}")

# 10. JSON data analysis
print("\n10. JSON DATA ANALYSIS:")
print("-"*40)

# Sample sales data
sales_data = {
    "sales": [
        {"product": "Laptop", "price": 1200, "quantity": 5, "date": "2024-01-15"},
        {"product": "Mouse", "price": 25, "quantity": 20, "date": "2024-01-15"},
        {"product": "Keyboard", "price": 80, "quantity": 10, "date": "2024-01-16"},
        {"product": "Monitor", "price": 350, "quantity": 3, "date": "2024-01-16"},
        {"product": "Laptop", "price": 1200, "quantity": 2, "date": "2024-01-17"},
        {"product": "Mouse", "price": 25, "quantity": 15, "date": "2024-01-17"}
    ]
}

# Analyze sales
total_revenue = 0
product_sales = {}

for sale in sales_data["sales"]:
    revenue = sale["price"] * sale["quantity"]
    total_revenue += revenue
    
    product = sale["product"]
    if product not in product_sales:
        product_sales[product] = 0
    product_sales[product] += revenue

print(f"Total Revenue: ${total_revenue}")
print("\nRevenue by Product:")
for product, revenue in sorted(product_sales.items(), key=lambda x: -x[1]):
    print(f"  {product}: ${revenue}")

# Save analysis
with open("sales_analysis.json", "w") as f:
    analysis = {
        "total_revenue": total_revenue,
        "product_breakdown": product_sales,
        "timestamp": datetime.datetime.now().isoformat()
    }
    json.dump(analysis, f, indent=2)
print("\n‚úÖ Analysis saved to sales_analysis.json")

# Clean up
print("\nCleaning up JSON files...")
for f in ["data.json", "complex.json", "special.json", "config.json", "sales_analysis.json"]:
    if os.path.exists(f):
        os.remove(f)
        print(f"Removed {f}")
# json_handling.py
"""
JSON data handling in Python
"""

print("="*60)
print("JSON DATA HANDLING")
print("="*60)

import json
import datetime
from pathlib import Path

# 1. Basic JSON serialization
print("\n1. BASIC JSON SERIALIZATION:")
print("-"*40)

# Python dictionary
data = {
    "name": "Alice",
    "age": 30,
    "city": "New York",
    "hobbies": ["reading", "cycling", "photography"],
    "married": False,
    "salary": 75000.50,
    "projects": None
}

print("Python dictionary:")
print(data)

# Convert to JSON string
json_string = json.dumps(data, indent=2)
print("\nJSON string:")
print(json_string)

# Convert back to Python
parsed_data = json.loads(json_string)
print("\nParsed back to Python:")
print(parsed_data)
print(f"Type after parsing: {type(parsed_data)}")

# 2. Writing JSON to file
print("\n2. WRITING JSON TO FILE:")
print("-"*40)

# Write to file
with open("data.json", "w") as f:
    json.dump(data, f, indent=4)
print("‚úÖ Data written to data.json")

# 3. Reading JSON from file
print("\n3. READING JSON FROM FILE:")
print("-"*40)

with open("data.json", "r") as f:
    loaded_data = json.load(f)
print("‚úÖ Data loaded from data.json")
print(f"Loaded: {loaded_data}")

# 4. Complex data structures
print("\n4. COMPLEX DATA STRUCTURES:")
print("-"*40)

complex_data = {
    "users": [
        {"id": 1, "name": "Alice", "scores": [85, 92, 78]},
        {"id": 2, "name": "Bob", "scores": [90, 88, 95]},
        {"id": 3, "name": "Charlie", "scores": [76, 89, 82]}
    ],
    "metadata": {
        "version": "1.0",
        "last_updated": "2024-01-15",
        "total_users": 3
    },
    "settings": {
        "theme": "dark",
        "notifications": True,
        "language": "en"
    }
}

with open("complex.json", "w") as f:
    json.dump(complex_data, f, indent=2)
print("‚úÖ Complex data saved to complex.json")

# Read and process
with open("complex.json", "r") as f:
    data = json.load(f)
    
print("\nProcessing complex data:")
for user in data["users"]:
    avg_score = sum(user["scores"]) / len(user["scores"])
    print(f"  {user['name']}: average score = {avg_score:.1f}")

# 5. Handling special types
print("\n5. HANDLING SPECIAL TYPES:")
print("-"*40)

class CustomEncoder(json.JSONEncoder):
    """Custom JSON encoder for special types"""
    
    def default(self, obj):
        if isinstance(obj, datetime.datetime):
            return obj.isoformat()
        if isinstance(obj, datetime.date):
            return obj.isoformat()
        if isinstance(obj, set):
            return list(obj)
        if isinstance(obj, Path):
            return str(obj)
        return super().default(obj)

# Data with special types
special_data = {
    "timestamp": datetime.datetime.now(),
    "date": datetime.date.today(),
    "unique_ids": {1, 2, 3, 4, 5},
    "file_path": Path("/home/user/data.txt"),
    "name": "Special Data"
}

# Serialize with custom encoder
json_str = json.dumps(special_data, cls=CustomEncoder, indent=2)
print("Serialized with custom encoder:")
print(json_str)

# Save to file
with open("special.json", "w") as f:
    json.dump(special_data, f, cls=CustomEncoder, indent=2)
print("‚úÖ Special data saved to special.json")

# 6. Pretty printing
print("\n6. PRETTY PRINTING:")
print("-"*40)

ugly_json = '{"name":"Alice","age":30,"city":"New York","hobbies":["reading","cycling"]}'
print("Ugly JSON:", ugly_json)

# Pretty print
parsed = json.loads(ugly_json)
pretty = json.dumps(parsed, indent=4, sort_keys=True)
print("Pretty printed:")
print(pretty)

# 7. JSON validation
print("\n7. JSON VALIDATION:")
print("-"*40)

def validate_json(json_string):
    """Validate JSON string"""
    try:
        json.loads(json_string)
        return True, "Valid JSON"
    except json.JSONDecodeError as e:
        return False, str(e)

# Test valid JSON
valid_json = '{"name": "Alice", "age": 30}'
is_valid, message = validate_json(valid_json)
print(f"Valid JSON: {is_valid} - {message}")

# Test invalid JSON
invalid_json = '{"name": "Alice", "age": 30,}'  # Trailing comma
is_valid, message = validate_json(invalid_json)
print(f"Invalid JSON: {is_valid} - {message}")

# 8. JSON minify (remove whitespace)
print("\n8. JSON MINIFY:")
print("-"*40)

def minify_json(json_string):
    """Remove unnecessary whitespace from JSON"""
    parsed = json.loads(json_string)
    return json.dumps(parsed, separators=(',', ':'))

verbose_json = """
{
    "name": "Alice",
    "age": 30,
    "city": "New York",
    "hobbies": [
        "reading",
        "cycling"
    ]
}
"""

minified = minify_json(verbose_json)
print("Minified JSON:")
print(minified)
print(f"Length: original={len(verbose_json)}, minified={len(minified)}")

# 9. JSON configuration file example
print("\n9. CONFIGURATION FILE EXAMPLE:")
print("-"*40)

config = {
    "app_name": "Task Manager",
    "version": "2.1.0",
    "debug": False,
    "database": {
        "host": "localhost",
        "port": 5432,
        "name": "taskdb",
        "user": "admin",
        "password": "secret123"
    },
    "logging": {
        "level": "INFO",
        "file": "app.log",
        "max_size": 10485760,
        "backup_count": 5
    },
    "features": {
        "dark_mode": True,
        "notifications": True,
        "auto_save": True,
        "sync_interval": 300
    }
}

# Save config
with open("config.json", "w") as f:
    json.dump(config, f, indent=2)
print("‚úÖ Configuration saved to config.json")

# Load and use config
with open("config.json", "r") as f:
    loaded_config = json.load(f)
    
print("\nConfiguration loaded:")
print(f"App: {loaded_config['app_name']} v{loaded_config['version']}")
print(f"Database: {loaded_config['database']['host']}:{loaded_config['database']['port']}")
print(f"Debug mode: {loaded_config['debug']}")

# 10. JSON data analysis
print("\n10. JSON DATA ANALYSIS:")
print("-"*40)

# Sample sales data
sales_data = {
    "sales": [
        {"product": "Laptop", "price": 1200, "quantity": 5, "date": "2024-01-15"},
        {"product": "Mouse", "price": 25, "quantity": 20, "date": "2024-01-15"},
        {"product": "Keyboard", "price": 80, "quantity": 10, "date": "2024-01-16"},
        {"product": "Monitor", "price": 350, "quantity": 3, "date": "2024-01-16"},
        {"product": "Laptop", "price": 1200, "quantity": 2, "date": "2024-01-17"},
        {"product": "Mouse", "price": 25, "quantity": 15, "date": "2024-01-17"}
    ]
}

# Analyze sales
total_revenue = 0
product_sales = {}

for sale in sales_data["sales"]:
    revenue = sale["price"] * sale["quantity"]
    total_revenue += revenue
    
    product = sale["product"]
    if product not in product_sales:
        product_sales[product] = 0
    product_sales[product] += revenue

print(f"Total Revenue: ${total_revenue}")
print("\nRevenue by Product:")
for product, revenue in sorted(product_sales.items(), key=lambda x: -x[1]):
    print(f"  {product}: ${revenue}")

# Save analysis
with open("sales_analysis.json", "w") as f:
    analysis = {
        "total_revenue": total_revenue,
        "product_breakdown": product_sales,
        "timestamp": datetime.datetime.now().isoformat()
    }
    json.dump(analysis, f, indent=2)
print("\n‚úÖ Analysis saved to sales_analysis.json")

# Clean up
print("\nCleaning up JSON files...")
for f in ["data.json", "complex.json", "special.json", "config.json", "sales_analysis.json"]:
    if os.path.exists(f):
        os.remove(f)
        print(f"Removed {f}")

Output:

============================================================
JSON DATA HANDLING
============================================================

1. BASIC JSON SERIALIZATION:
----------------------------------------
Python dictionary:
{'name': 'Alice', 'age': 30, 'city': 'New York', 'hobbies': ['reading', 'cycling', 'photography'], 'married': False, 'salary': 75000.5, 'projects': None}

JSON string:
{
  "name": "Alice",
  "age": 30,
  "city": "New York",
  "hobbies": [
    "reading",
    "cycling",
    "photography"
  ],
  "married": false,
  "salary": 75000.5,
  "projects": null
}

Parsed back to Python:
{'name': 'Alice', 'age': 30, 'city': 'New York', 'hobbies': ['reading', 'cycling', 'photography'], 'married': False, 'salary': 75000.5, 'projects': None}
Type after parsing: <class 'dict'>

2. WRITING JSON TO FILE:
----------------------------------------
‚úÖ Data written to data.json

3. READING JSON FROM FILE:
----------------------------------------
‚úÖ Data loaded from data.json
Loaded: {'name': 'Alice', 'age': 30, 'city': 'New York', 'hobbies': ['reading', 'cycling', 'photography'], 'married': False, 'salary': 75000.5, 'projects': None}

4. COMPLEX DATA STRUCTURES:
----------------------------------------
‚úÖ Complex data saved to complex.json

Processing complex data:
  Alice: average score = 85.0
  Bob: average score = 91.0
  Charlie: average score = 82.3

5. HANDLING SPECIAL TYPES:
----------------------------------------
Serialized with custom encoder:
{
  "timestamp": "2024-01-16T15:30:45.123456",
  "date": "2024-01-16",
  "unique_ids": [1, 2, 3, 4, 5],
  "file_path": "/home/user/data.txt",
  "name": "Special Data"
}
‚úÖ Special data saved to special.json

6. PRETTY PRINTING:
----------------------------------------
Ugly JSON: {"name":"Alice","age":30,"city":"New York","hobbies":["reading","cycling"]}
Pretty printed:
{
    "age": 30,
    "city": "New York",
    "hobbies": [
        "reading",
        "cycling"
    ],
    "name": "Alice"
}

7. JSON VALIDATION:
----------------------------------------
Valid JSON: True - Valid JSON
Invalid JSON: False - Expecting property name enclosed in double quotes: line 1 column 30 (char 29)

8. JSON MINIFY:
----------------------------------------
Minified JSON:
{"name":"Alice","age":30,"city":"New York","hobbies":["reading","cycling"]}
Length: original=98, minified=64

9. CONFIGURATION FILE EXAMPLE:
----------------------------------------
‚úÖ Configuration saved to config.json

Configuration loaded:
App: Task Manager v2.1.0
Database: localhost:5432
Debug mode: False

10. JSON DATA ANALYSIS:
----------------------------------------
Total Revenue: $10975

Revenue by Product:
  Laptop: $8400
  Mouse: $875
  Keyboard: $800
  Monitor: $1050

‚úÖ Analysis saved to sales_analysis.json

Cleaning up JSON files...
Removed data.json
Removed complex.json
Removed special.json
Removed config.json
Removed sales_analysis.json



