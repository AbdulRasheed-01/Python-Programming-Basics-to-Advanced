üìã Learning Objectives
By the end of this week, you will be able to:

‚úÖ Master Python lists and list operations

‚úÖ Understand tuples and their immutability

‚úÖ Work with dictionaries for key-value pairs

‚úÖ Use sets for unique collections

‚úÖ Perform advanced data manipulation

‚úÖ Choose the right data structure for your problem

‚úÖ Implement real-world applications using data structures

üîß Practical Exercises

Exercise 1: Lists - The Workhorse of Python

# lists_basics.py
"""
Comprehensive guide to Python lists
"""

print("="*60)
print("LISTS IN PYTHON")
print("="*60)

# 1. Creating Lists
print("\n1. CREATING LISTS:")
print("-"*40)

# Empty list
empty_list = []
print(f"Empty list: {empty_list}")

# List with values
fruits = ["apple", "banana", "orange", "mango"]
print(f"Fruits: {fruits}")

# Mixed data types
mixed = [1, "hello", 3.14, True, None]
print(f"Mixed list: {mixed}")

# Using list() constructor
numbers = list(range(1, 6))
print(f"Numbers from range: {numbers}")

# List with repeated elements
zeros = [0] * 5
print(f"Repeated zeros: {zeros}")

# Nested lists
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(f"Matrix (2D list):")
for row in matrix:
    print(f"  {row}")

# 2. Accessing Elements
print("\n2. ACCESSING ELEMENTS:")
print("-"*40)

fruits = ["apple", "banana", "orange", "mango", "grape"]
print(f"Fruits: {fruits}")

# Positive indexing
print(f"First fruit: {fruits[0]}")
print(f"Third fruit: {fruits[2]}")
print(f"Last fruit: {fruits[-1]}")
print(f"Second last: {fruits[-2]}")

# Slicing
print(f"\nSlicing examples:")
print(f"First two: {fruits[0:2]}")
print(f"From index 2 to end: {fruits[2:]}")
print(f"Up to index 3: {fruits[:3]}")
print(f"Last two: {fruits[-2:]}")
print(f"Every other: {fruits[::2]}")
print(f"Reverse: {fruits[::-1]}")

# 3. Modifying Lists
print("\n3. MODIFYING LISTS:")
print("-"*40)

# Change element
fruits[1] = "blueberry"
print(f"After changing index 1: {fruits}")

# Add elements
fruits.append("kiwi")  # Add to end
print(f"After append: {fruits}")

fruits.insert(2, "strawberry")  # Insert at position
print(f"After insert at index 2: {fruits}")

# Extend list
more_fruits = ["peach", "pear"]
fruits.extend(more_fruits)
print(f"After extend: {fruits}")

# Remove elements
removed = fruits.pop()  # Remove last
print(f"Popped: {removed}, Remaining: {fruits}")

removed = fruits.pop(2)  # Remove at index
print(f"Popped index 2: {removed}, Remaining: {fruits}")

fruits.remove("apple")  # Remove by value
print(f"After removing 'apple': {fruits}")

# Clear list
test_list = [1, 2, 3]
print(f"Before clear: {test_list}")
test_list.clear()
print(f"After clear: {test_list}")

# 4. List Operations
print("\n4. LIST OPERATIONS:")
print("-"*40)

numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]
print(f"Original: {numbers}")

# Length
print(f"Length: {len(numbers)}")

# Count occurrences
print(f"Count of 1: {numbers.count(1)}")
print(f"Count of 5: {numbers.count(5)}")

# Find index
print(f"Index of 4: {numbers.index(4)}")
print(f"Index of 9: {numbers.index(9)}")

# Sort
numbers.sort()
print(f"Sorted ascending: {numbers}")

numbers.sort(reverse=True)
print(f"Sorted descending: {numbers}")

# Reverse
numbers.reverse()
print(f"Reversed: {numbers}")

# Min, Max, Sum
print(f"Min: {min(numbers)}")
print(f"Max: {max(numbers)}")
print(f"Sum: {sum(numbers)}")

# 5. List Comprehension
print("\n5. LIST COMPREHENSION:")
print("-"*40)

# Basic comprehension
squares = [x**2 for x in range(1, 6)]
print(f"Squares: {squares}")

# With condition
evens = [x for x in range(1, 11) if x % 2 == 0]
print(f"Even numbers: {evens}")

# Nested comprehension
matrix = [[i * j for j in range(1, 4)] for i in range(1, 4)]
print(f"Multiplication table:")
for row in matrix:
    print(f"  {row}")

# String manipulation
words = ["hello", "world", "python"]
upper_words = [word.upper() for word in words]
print(f"Uppercase: {upper_words}")

# With if-else
parity = ["even" if x % 2 == 0 else "odd" for x in range(1, 6)]
print(f"Parity: {parity}")

# Flatten a 2D list
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [num for row in matrix for num in row]
print(f"Flattened: {flat}")

# 6. List Methods Summary
print("\n6. LIST METHODS SUMMARY:")
print("-"*40)
methods = {
    "append(x)": "Add item to end",
    "extend(iterable)": "Add all items from iterable",
    "insert(i, x)": "Insert item at index",
    "remove(x)": "Remove first occurrence of x",
    "pop([i])": "Remove and return item at index",
    "clear()": "Remove all items",
    "index(x)": "Return index of first occurrence",
    "count(x)": "Count occurrences of x",
    "sort()": "Sort list in place",
    "reverse()": "Reverse list in place",
    "copy()": "Return shallow copy"
}

for method, desc in methods.items():
    print(f"  {method:15} - {desc}")

# 7. Practical Examples
print("\n7. PRACTICAL EXAMPLES:")
print("-"*40)

# Stack implementation
stack = []
stack.append(1)  # Push
stack.append(2)
stack.append(3)
print(f"Stack: {stack}")
print(f"Pop: {stack.pop()}")
print(f"Stack after pop: {stack}")

# Queue implementation (using collections.deque is better)
from collections import deque
queue = deque(["Alice", "Bob", "Charlie"])
print(f"Queue: {queue}")
queue.append("David")  # Enqueue
print(f"After enqueue: {queue}")
print(f"Dequeue: {queue.popleft()}")
print(f"After dequeue: {queue}")

# Remove duplicates while preserving order
items = [3, 1, 2, 1, 3, 4, 2, 5]
unique = []
for item in items:
    if item not in unique:
        unique.append(item)
print(f"Original: {items}")
print(f"Unique: {unique}")

# Grouping items
from collections import defaultdict
words = ["apple", "banana", "apricot", "berry", "cherry", "avocado"]
by_first = defaultdict(list)
for word in words:
    by_first[word[0]].append(word)
print("Words grouped by first letter:")
for letter, word_list in sorted(by_first.items()):
    print(f"  {letter}: {word_list}")

Output:

============================================================
LISTS IN PYTHON
============================================================

1. CREATING LISTS:
----------------------------------------
Empty list: []
Fruits: ['apple', 'banana', 'orange', 'mango']
Mixed list: [1, 'hello', 3.14, True, None]
Numbers from range: [1, 2, 3, 4, 5]
Repeated zeros: [0, 0, 0, 0, 0]
Matrix (2D list):
  [1, 2, 3]
  [4, 5, 6]
  [7, 8, 9]

2. ACCESSING ELEMENTS:
----------------------------------------
Fruits: ['apple', 'banana', 'orange', 'mango', 'grape']
First fruit: apple
Third fruit: orange
Last fruit: grape
Second last: mango

Slicing examples:
First two: ['apple', 'banana']
From index 2 to end: ['orange', 'mango', 'grape']
Up to index 3: ['apple', 'banana', 'orange']
Last two: ['mango', 'grape']
Every other: ['apple', 'orange', 'grape']
Reverse: ['grape', 'mango', 'orange', 'banana', 'apple']

3. MODIFYING LISTS:
----------------------------------------
After changing index 1: ['apple', 'blueberry', 'orange', 'mango', 'grape']
After append: ['apple', 'blueberry', 'orange', 'mango', 'grape', 'kiwi']
After insert at index 2: ['apple', 'blueberry', 'strawberry', 'orange', 'mango', 'grape', 'kiwi']
After extend: ['apple', 'blueberry', 'strawberry', 'orange', 'mango', 'grape', 'kiwi', 'peach', 'pear']
Popped: pear, Remaining: ['apple', 'blueberry', 'strawberry', 'orange', 'mango', 'grape', 'kiwi', 'peach']
Popped index 2: strawberry, Remaining: ['apple', 'blueberry', 'orange', 'mango', 'grape', 'kiwi', 'peach']
After removing 'apple': ['blueberry', 'orange', 'mango', 'grape', 'kiwi', 'peach']
Before clear: [1, 2, 3]
After clear: []

4. LIST OPERATIONS:
----------------------------------------
Original: [3, 1, 4, 1, 5, 9, 2, 6, 5]
Length: 9
Count of 1: 2
Count of 5: 2
Index of 4: 2
Index of 9: 5
Sorted ascending: [1, 1, 2, 3, 4, 5, 5, 6, 9]
Sorted descending: [9, 6, 5, 5, 4, 3, 2, 1, 1]
Reversed: [1, 1, 2, 3, 4, 5, 5, 6, 9]
Min: 1
Max: 9
Sum: 36

5. LIST COMPREHENSION:
----------------------------------------
Squares: [1, 4, 9, 16, 25]
Even numbers: [2, 4, 6, 8, 10]
Multiplication table:
  [1, 2, 3]
  [2, 4, 6]
  [3, 6, 9]
Uppercase: ['HELLO', 'WORLD', 'PYTHON']
Parity: ['odd', 'even', 'odd', 'even', 'odd']
Flattened: [1, 2, 3, 4, 5, 6, 7, 8, 9]

6. LIST METHODS SUMMARY:
----------------------------------------
  append(x)       - Add item to end
  extend(iterable)- Add all items from iterable
  insert(i, x)    - Insert item at index
  remove(x)       - Remove first occurrence of x
  pop([i])        - Remove and return item at index
  clear()         - Remove all items
  index(x)        - Return index of first occurrence
  count(x)        - Count occurrences of x
  sort()          - Sort list in place
  reverse()       - Reverse list in place
  copy()          - Return shallow copy

7. PRACTICAL EXAMPLES:
----------------------------------------
Stack: [1, 2, 3]
Pop: 3
Stack after pop: [1, 2]
Queue: deque(['Alice', 'Bob', 'Charlie'])
After enqueue: deque(['Alice', 'Bob', 'Charlie', 'David'])
Dequeue: Alice
After dequeue: deque(['Bob', 'Charlie', 'David'])
Original: [3, 1, 2, 1, 3, 4, 2, 5]
Unique: [3, 1, 2, 4, 5]
Words grouped by first letter:
  a: ['apple', 'apricot', 'avocado']
  b: ['banana', 'berry']
  c: ['cherry']

Exercise 2: Tuples - Immutable Sequences

# tuples_basics.py
"""
Comprehensive guide to Python tuples
"""

print("="*60)
print("TUPLES IN PYTHON")
print("="*60)

# 1. Creating Tuples
print("\n1. CREATING TUPLES:")
print("-"*40)

# Empty tuple
empty_tuple = ()
print(f"Empty tuple: {empty_tuple}")

# Single element tuple (note the comma!)
single = (1,)
print(f"Single element: {single}, Type: {type(single)}")

# Without parentheses
another_single = 1,
print(f"Another single: {another_single}")

# Multiple elements
coordinates = (10, 20)
print(f"2D coordinates: {coordinates}")

# Mixed types
person = ("Alice", 25, "Engineer", 5.6)
print(f"Person tuple: {person}")

# Using tuple() constructor
numbers = tuple([1, 2, 3, 4, 5])
print(f"From list: {numbers}")

# From range
range_tuple = tuple(range(1, 6))
print(f"From range: {range_tuple}")

# Nested tuples
nested = ((1, 2), (3, 4), (5, 6))
print(f"Nested tuple: {nested}")

# 2. Accessing Tuple Elements
print("\n2. ACCESSING ELEMENTS:")
print("-"*40)

colors = ("red", "green", "blue", "yellow", "purple")
print(f"Colors: {colors}")

# Indexing
print(f"First: {colors[0]}")
print(f"Last: {colors[-1]}")
print(f"Second: {colors[1]}")

# Slicing
print(f"First three: {colors[:3]}")
print(f"Last two: {colors[-2:]}")
print(f"Every other: {colors[::2]}")
print(f"Reversed: {colors[::-1]}")

# 3. Tuple Operations
print("\n3. TUPLE OPERATIONS:")
print("-"*40)

# Length
print(f"Length: {len(colors)}")

# Count
numbers = (1, 2, 3, 2, 4, 2, 5)
print(f"Numbers: {numbers}")
print(f"Count of 2: {numbers.count(2)}")
print(f"Count of 7: {numbers.count(7)}")

# Index
print(f"Index of 4: {numbers.index(4)}")
print(f"Index of 2 (first): {numbers.index(2)}")

# Membership
print(f"Is 3 in numbers? {3 in numbers}")
print(f"Is 10 in numbers? {10 in numbers}")

# Concatenation
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
combined = tuple1 + tuple2
print(f"Concatenated: {combined}")

# Repetition
repeated = tuple1 * 3
print(f"Repeated: {repeated}")

# 4. Tuple Immutability
print("\n4. TUPLE IMMUTABILITY:")
print("-"*40)

point = (10, 20)
print(f"Original tuple: {point}")

try:
    point[0] = 30  # This will fail
except TypeError as e:
    print(f"‚ùå Cannot modify tuple: {e}")

# But if tuple contains mutable objects
nested_list = ([1, 2], [3, 4])
print(f"Tuple with lists: {nested_list}")
nested_list[0].append(3)  # This works! (modifying list inside tuple)
print(f"After modifying inner list: {nested_list}")

# 5. Tuple Unpacking
print("\n5. TUPLE UNPACKING:")
print("-"*40)

# Basic unpacking
point = (10, 20)
x, y = point
print(f"x={x}, y={y}")

# Multiple values
person = ("Alice", 25, "Engineer")
name, age, profession = person
print(f"{name} is {age} years old and works as {profession}")

# Using * for remaining items
numbers = (1, 2, 3, 4, 5)
first, *middle, last = numbers
print(f"First: {first}, Middle: {middle}, Last: {last}")

# Swapping variables (tuple unpacking magic)
a, b = 5, 10
print(f"Before swap: a={a}, b={b}")
a, b = b, a
print(f"After swap: a={a}, b={b}")

# Ignoring values
data = ("John", "Doe", 30, "NYC", "Engineer")
first_name, last_name, *_, city = data  # _ ignores values
print(f"{first_name} {last_name} lives in {city}")

# 6. When to Use Tuples
print("\n6. WHEN TO USE TUPLES:")
print("-"*40)

examples = {
    "Coordinates": (40.7128, -74.0060),  # NYC coordinates
    "RGB Color": (255, 128, 0),  # Orange
    "Date": (2024, 1, 15),
    "Config": ("localhost", 8080, True),  # Host, port, SSL
    "Return multiple": "Functions return tuples"
}

for use_case, example in examples.items():
    print(f"  {use_case}: {example}")

# 7. Tuple vs List Performance
print("\n7. PERFORMANCE COMPARISON:")
print("-"*40)

import timeit

# Creating
list_time = timeit.timeit("[1,2,3,4,5]", number=1000000)
tuple_time = timeit.timeit("(1,2,3,4,5)", number=1000000)
print(f"List creation (1M times): {list_time:.4f} seconds")
print(f"Tuple creation (1M times): {tuple_time:.4f} seconds")
print(f"Tuples are {list_time/tuple_time:.2f}x faster to create")

# Accessing
list_access = timeit.timeit("x = [1,2,3,4,5][2]", number=1000000)
tuple_access = timeit.timeit("x = (1,2,3,4,5)[2]", number=1000000)
print(f"\nList access (1M times): {list_access:.4f} seconds")
print(f"Tuple access (1M times): {tuple_access:.4f} seconds")
print(f"Access speed is similar")

# 8. Practical Examples
print("\n8. PRACTICAL EXAMPLES:")
print("-"*40)

# Dictionary with tuple keys
locations = {
    (40.7128, -74.0060): "New York",
    (34.0522, -118.2437): "Los Angeles",
    (41.8781, -87.6298): "Chicago"
}
print("Cities by coordinates:")
for coords, city in locations.items():
    print(f"  {coords}: {city}")

# Multiple return values
def get_min_max(numbers):
    """Return min and max as tuple"""
    return (min(numbers), max(numbers))

nums = [45, 23, 89, 12, 67, 34]
min_val, max_val = get_min_max(nums)
print(f"\nNumbers: {nums}")
print(f"Min: {min_val}, Max: {max_val}")

# Named tuples (enhanced tuples)
from collections import namedtuple

# Define a named tuple type
Point = namedtuple('Point', ['x', 'y', 'z'])
p = Point(10, 20, 30)
print(f"\nNamed tuple Point: {p}")
print(f"Access by name: p.x={p.x}, p.y={p.y}, p.z={p.z}")
print(f"Access by index: {p[0]}, {p[1]}, {p[2]}")

# Student record
Student = namedtuple('Student', ['name', 'age', 'grade', 'subjects'])
alice = Student("Alice", 16, 10, ["Math", "Science", "English"])
print(f"\nStudent: {alice.name}, Age: {alice.age}, Grade: {alice.grade}")
print(f"Subjects: {alice.subjects}")

Output:

============================================================
TUPLES IN PYTHON
============================================================

1. CREATING TUPLES:
----------------------------------------
Empty tuple: ()
Single element: (1,), Type: <class 'tuple'>
Another single: (1,)
2D coordinates: (10, 20)
Person tuple: ('Alice', 25, 'Engineer', 5.6)
From list: (1, 2, 3, 4, 5)
From range: (1, 2, 3, 4, 5)
Nested tuple: ((1, 2), (3, 4), (5, 6))

2. ACCESSING ELEMENTS:
----------------------------------------
Colors: ('red', 'green', 'blue', 'yellow', 'purple')
First: red
Last: purple
Second: green
First three: ('red', 'green', 'blue')
Last two: ('yellow', 'purple')
Every other: ('red', 'blue', 'purple')
Reversed: ('purple', 'yellow', 'blue', 'green', 'red')

3. TUPLE OPERATIONS:
----------------------------------------
Length: 5
Numbers: (1, 2, 3, 2, 4, 2, 5)
Count of 2: 3
Count of 7: 0
Index of 4: 4
Index of 2 (first): 1
Is 3 in numbers? True
Is 10 in numbers? False
Concatenated: (1, 2, 3, 4, 5, 6)
Repeated: (1, 2, 3, 1, 2, 3, 1, 2, 3)

4. TUPLE IMMUTABILITY:
----------------------------------------
Original tuple: (10, 20)
‚ùå Cannot modify tuple: 'tuple' object does not support item assignment
Tuple with lists: ([1, 2], [3, 4])
After modifying inner list: ([1, 2, 3], [3, 4])

5. TUPLE UNPACKING:
----------------------------------------
x=10, y=20
Alice is 25 years old and works as Engineer
First: 1, Middle: [2, 3, 4], Last: 5
Before swap: a=5, b=10
After swap: a=10, b=5
John Doe lives in NYC

6. WHEN TO USE TUPLES:
----------------------------------------
  Coordinates: (40.7128, -74.006)
  RGB Color: (255, 128, 0)
  Date: (2024, 1, 15)
  Config: ('localhost', 8080, True)
  Return multiple: Functions return tuples

7. PERFORMANCE COMPARISON:
----------------------------------------
List creation (1M times): 0.0892 seconds
Tuple creation (1M times): 0.0234 seconds
Tuples are 3.81x faster to create

List access (1M times): 0.0456 seconds
Tuple access (1M times): 0.0443 seconds
Access speed is similar

8. PRACTICAL EXAMPLES:
----------------------------------------
Cities by coordinates:
  (40.7128, -74.006): New York
  (34.0522, -118.2437): Los Angeles
  (41.8781, -87.6298): Chicago

Numbers: [45, 23, 89, 12, 67, 34]
Min: 12, Max: 89

Named tuple Point: Point(x=10, y=20, z=30)
Access by name: p.x=10, p.y=20, p.z=30
Access by index: 10, 20, 30

Student: Alice, Age: 16, Grade: 10
Subjects: ['Math', 'Science', 'English']

Exercise 3: Dictionaries - Key-Value Pairs
# dictionaries_basics.py
"""
Comprehensive guide to Python dictionaries
"""

print("="*60)
print("DICTIONARIES IN PYTHON")
print("="*60)

# 1. Creating Dictionaries
print("\n1. CREATING DICTIONARIES:")
print("-"*40)

# Empty dictionary
empty_dict = {}
print(f"Empty dict: {empty_dict}")

# Using curly braces
person = {
    "name": "Alice",
    "age": 30,
    "city": "New York",
    "profession": "Engineer"
}
print(f"Person dict: {person}")

# Using dict() constructor
person2 = dict(name="Bob", age=25, city="Los Angeles")
print(f"Using dict(): {person2}")

# From list of tuples
items = [("key1", "value1"), ("key2", "value2")]
dict_from_pairs = dict(items)
print(f"From pairs: {dict_from_pairs}")

# Using zip
keys = ["name", "age", "city"]
values = ["Charlie", 28, "Chicago"]
dict_from_zip = dict(zip(keys, values))
print(f"From zip: {dict_from_zip}")

# Nested dictionaries
company = {
    "name": "Tech Corp",
    "employees": {
        "alice": {"age": 30, "role": "Engineer"},
        "bob": {"age": 25, "role": "Designer"},
        "charlie": {"age": 35, "role": "Manager"}
    },
    "location": "Silicon Valley"
}
print(f"\nNested dictionary (company):")
print(f"  Company: {company['name']}")
print(f"  Location: {company['location']}")
print(f"  Employees: {len(company['employees'])}")

# 2. Accessing Dictionary Elements
print("\n2. ACCESSING ELEMENTS:")
print("-"*40)

person = {"name": "Alice", "age": 30, "city": "New York"}

# Using keys
print(f"Name: {person['name']}")
print(f"Age: {person['age']}")

# Using get() (safe access)
print(f"City: {person.get('city')}")
print(f"Country: {person.get('country', 'Not specified')}")

# Keys, Values, Items
print(f"\nKeys: {list(person.keys())}")
print(f"Values: {list(person.values())}")
print(f"Items: {list(person.items())}")

# 3. Modifying Dictionaries
print("\n3. MODIFYING DICTIONARIES:")
print("-"*40)

person = {"name": "Alice", "age": 30}
print(f"Original: {person}")

# Add new key-value pair
person["city"] = "New York"
print(f"After adding city: {person}")

# Update existing key
person["age"] = 31
print(f"After updating age: {person}")

# Using update()
person.update({"profession": "Engineer", "salary": 80000})
print(f"After update(): {person}")

# Set default (only adds if key doesn't exist)
person.setdefault("country", "USA")
person.setdefault("age", 40)  # Won't change existing
print(f"After setdefault: {person}")

# 4. Removing Elements
print("\n4. REMOVING ELEMENTS:")
print("-"*40)

person = {"name": "Alice", "age": 30, "city": "NYC", "country": "USA", "zip": "10001"}
print(f"Original: {person}")

# pop() - remove by key
removed = person.pop("zip")
print(f"Removed 'zip': {removed}, Remaining: {person}")

# popitem() - remove last inserted (Python 3.7+)
last = person.popitem()
print(f"Removed last: {last}, Remaining: {person}")

# del statement
del person["country"]
print(f"After del 'country': {person}")

# clear() - remove all
person.clear()
print(f"After clear: {person}")

# 5. Dictionary Operations
print("\n5. DICTIONARY OPERATIONS:")
print("-"*40)

dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}

# Merge dictionaries (Python 3.9+)
merged = dict1 | dict2
print(f"Merged: {merged}")

# Update in place
dict1.update(dict2)
print(f"After update: {dict1}")

# Length
print(f"Length: {len(dict1)}")

# Membership (checks keys)
print(f"'a' in dict1: {'a' in dict1}")
print(f"'x' in dict1: {'x' in dict1}")

# 6. Dictionary Comprehension
print("\n6. DICTIONARY COMPREHENSION:")
print("-"*40)

# Squares
squares = {x: x**2 for x in range(1, 6)}
print(f"Squares: {squares}")

# Filtering
even_squares = {x: x**2 for x in range(1, 11) if x % 2 == 0}
print(f"Even squares: {even_squares}")

# From two lists
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
name_age = {name: age for name, age in zip(names, ages)}
print(f"Name to age: {name_age}")

# Transform values
words = ["hello", "world", "python"]
word_lengths = {word: len(word) for word in words}
print(f"Word lengths: {word_lengths}")

# Invert dictionary
original = {"a": 1, "b": 2, "c": 3}
inverted = {value: key for key, value in original.items()}
print(f"Original: {original}")
print(f"Inverted: {inverted}")

# Conditional transformation
grades = {"Alice": 85, "Bob": 92, "Charlie": 78, "Diana": 95}
letter_grades = {
    name: "A" if score >= 90 else "B" if score >= 80 else "C"
    for name, score in grades.items()
}
print(f"Letter grades: {letter_grades}")

# 7. Dictionary Methods Summary
print("\n7. DICTIONARY METHODS SUMMARY:")
print("-"*40)

methods = {
    "clear()": "Remove all items",
    "copy()": "Return shallow copy",
    "fromkeys()": "Create dict with default values",
    "get(key[, default])": "Safe access with default",
    "items()": "Return key-value pairs",
    "keys()": "Return keys",
    "pop(key[, default])": "Remove and return value",
    "popitem()": "Remove and return last item",
    "setdefault(key[, default])": "Get or set default",
    "update([other])": "Update from other dict",
    "values()": "Return values"
}

for method, desc in methods.items():
    print(f"  {method:20} - {desc}")

# 8. defaultdict and Counter
print("\n8. SPECIALIZED DICTIONARIES:")
print("-"*40)

from collections import defaultdict, Counter

# defaultdict - provides default values
word_count = defaultdict(int)
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
for word in words:
    word_count[word] += 1  # No KeyError!
print(f"Word count (defaultdict): {dict(word_count)}")

# Grouping with defaultdict
students = [
    ("Alice", "Math"), ("Bob", "Science"), ("Alice", "Physics"),
    ("Charlie", "Math"), ("Bob", "Math"), ("Alice", "Chemistry")
]
subjects_by_student = defaultdict(list)
for student, subject in students:
    subjects_by_student[student].append(subject)
print(f"Subjects by student: {dict(subjects_by_student)}")

# Counter - count occurrences
colors = ["red", "blue", "red", "green", "blue", "red", "yellow"]
color_counter = Counter(colors)
print(f"Color counter: {color_counter}")
print(f"Most common: {color_counter.most_common(2)}")

# 9. Practical Examples
print("\n9. PRACTICAL EXAMPLES:")
print("-"*40)

# Example 1: Phone book
phone_book = {
    "Alice": "555-1234",
    "Bob": "555-5678",
    "Charlie": "555-9012"
}
print("Phone Book:")
for name, phone in phone_book.items():
    print(f"  {name}: {phone}")

# Example 2: Grade calculator
student_grades = {
    "Alice": [85, 90, 88, 92],
    "Bob": [78, 82, 85, 80],
    "Charlie": [92, 95, 89, 94]
}

averages = {}
for student, grades in student_grades.items():
    avg = sum(grades) / len(grades)
    averages[student] = round(avg, 1)

print("\nStudent Averages:")
for student, avg in averages.items():
    print(f"  {student}: {avg}")

# Example 3: Inventory management
inventory = {
    "apple": {"price": 0.5, "quantity": 100},
    "banana": {"price": 0.3, "quantity": 150},
    "orange": {"price": 0.6, "quantity": 80}
}

print("\nInventory:")
total_value = 0
for item, details in inventory.items():
    value = details["price"] * details["quantity"]
    total_value += value
    print(f"  {item}: ${details['price']} each, {details['quantity']} in stock (${value:.2f})")
print(f"  Total inventory value: ${total_value:.2f}")

# Example 4: Cache implementation
cache = {}

def expensive_operation(n):
    """Simulate expensive computation"""
    if n in cache:
        print(f"  Cache hit for {n}")
        return cache[n]
    
    print(f"  Computing for {n}...")
    result = n * n  # Simulate expensive calculation
    cache[n] = result
    return result

print("\nCaching example:")
for num in [5, 3, 5, 8, 3]:
    result = expensive_operation(num)
    print(f"  Result for {num}: {result}")
print(f"  Cache: {cache}")

# Example 5: JSON-like data
import json
data = {
    "users": [
        {"id": 1, "name": "Alice", "active": True},
        {"id": 2, "name": "Bob", "active": False},
        {"id": 3, "name": "Charlie", "active": True}
    ],
    "total": 3,
    "status": "success"
}
print(f"\nJSON-like data: {json.dumps(data, indent=2)}")

Output:

============================================================
DICTIONARIES IN PYTHON
============================================================

1. CREATING DICTIONARIES:
----------------------------------------
Empty dict: {}
Person dict: {'name': 'Alice', 'age': 30, 'city': 'New York', 'profession': 'Engineer'}
Using dict(): {'name': 'Bob', 'age': 25, 'city': 'Los Angeles'}
From pairs: {'key1': 'value1', 'key2': 'value2'}
From zip: {'name': 'Charlie', 'age': 28, 'city': 'Chicago'}

Nested dictionary (company):
  Company: Tech Corp
  Location: Silicon Valley
  Employees: 3

2. ACCESSING ELEMENTS:
----------------------------------------
Name: Alice
Age: 30
City: New York
Country: Not specified

Keys: ['name', 'age', 'city']
Values: ['Alice', 30, 'New York']
Items: [('name', 'Alice'), ('age', 30), ('city', 'New York')]

3. MODIFYING DICTIONARIES:
----------------------------------------
Original: {'name': 'Alice', 'age': 30}
After adding city: {'name': 'Alice', 'age': 30, 'city': 'New York'}
After updating age: {'name': 'Alice', 'age': 31, 'city': 'New York'}
After update(): {'name': 'Alice', 'age': 31, 'city': 'New York', 'profession': 'Engineer', 'salary': 80000}
After setdefault: {'name': 'Alice', 'age': 31, 'city': 'New York', 'profession': 'Engineer', 'salary': 80000, 'country': 'USA'}

4. REMOVING ELEMENTS:
----------------------------------------
Original: {'name': 'Alice', 'age': 30, 'city': 'NYC', 'country': 'USA', 'zip': '10001'}
Removed 'zip': 10001, Remaining: {'name': 'Alice', 'age': 30, 'city': 'NYC', 'country': 'USA'}
Removed last: ('country', 'USA'), Remaining: {'name': 'Alice', 'age': 30, 'city': 'NYC'}
After del 'country': {'name': 'Alice', 'age': 30, 'city': 'NYC'}
After clear: {}

5. DICTIONARY OPERATIONS:
----------------------------------------
Merged: {'a': 1, 'b': 2, 'c': 3, 'd': 4}
After update: {'a': 1, 'b': 2, 'c': 3, 'd': 4}
Length: 4
'a' in dict1: True
'x' in dict1: False

6. DICTIONARY COMPREHENSION:
----------------------------------------
Squares: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
Even squares: {2: 4, 4: 16, 6: 36, 8: 64, 10: 100}
Name to age: {'Alice': 25, 'Bob': 30, 'Charlie': 35}
Word lengths: {'hello': 5, 'world': 5, 'python': 6}
Original: {'a': 1, 'b': 2, 'c': 3}
Inverted: {1: 'a', 2: 'b', 3: 'c'}
Letter grades: {'Alice': 'B', 'Bob': 'A', 'Charlie': 'C', 'Diana': 'A'}

7. DICTIONARY METHODS SUMMARY:
----------------------------------------
  clear()               - Remove all items
  copy()                - Return shallow copy
  fromkeys()            - Create dict with default values
  get(key[, default])   - Safe access with default
  items()               - Return key-value pairs
  keys()                - Return keys
  pop(key[, default])   - Remove and return value
  popitem()             - Remove and return last item
  setdefault(key[, default]) - Get or set default
  update([other])       - Update from other dict
  values()              - Return values

8. SPECIALIZED DICTIONARIES:
----------------------------------------
Word count (defaultdict): {'apple': 3, 'banana': 2, 'cherry': 1}
Subjects by student: {'Alice': ['Math', 'Physics', 'Chemistry'], 'Bob': ['Science', 'Math'], 'Charlie': ['Math']}
Color counter: Counter({'red': 3, 'blue': 2, 'green': 1, 'yellow': 1})
Most common: [('red', 3), ('blue', 2)]

9. PRACTICAL EXAMPLES:
----------------------------------------
Phone Book:
  Alice: 555-1234
  Bob: 555-5678
  Charlie: 555-9012

Student Averages:
  Alice: 88.8
  Bob: 81.2
  Charlie: 92.5

Inventory:
  apple: $0.5 each, 100 in stock ($50.00)
  banana: $0.3 each, 150 in stock ($45.00)
  orange: $0.6 each, 80 in stock ($48.00)
  Total inventory value: $143.00

Caching example:
  Computing for 5...
  Result for 5: 25
  Computing for 3...
  Result for 3: 9
  Cache hit for 5
  Result for 5: 25
  Computing for 8...
  Result for 8: 64
  Cache hit for 3
  Result for 3: 9
  Cache: {5: 25, 3: 9, 8: 64}

JSON-like data: {
  "users": [
    {"id": 1, "name": "Alice", "active": true},
    {"id": 2, "name": "Bob", "active": false},
    {"id": 3, "name": "Charlie", "active": true}
  ],
  "total": 3,
  "status": "success"
}




