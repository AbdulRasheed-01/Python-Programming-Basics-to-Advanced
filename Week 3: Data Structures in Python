ðŸ“‹ Learning Objectives
By the end of this week, you will be able to:

âœ… Master Python lists and list operations

âœ… Understand tuples and their immutability

âœ… Work with dictionaries for key-value pairs

âœ… Use sets for unique collections

âœ… Perform advanced data manipulation

âœ… Choose the right data structure for your problem

âœ… Implement real-world applications using data structures

ðŸ”§ Practical Exercises

Exercise 1: Lists - The Workhorse of Python

# lists_basics.py
"""
Comprehensive guide to Python lists
"""

print("="*60)
print("LISTS IN PYTHON")
print("="*60)

# 1. Creating Lists
print("\n1. CREATING LISTS:")
print("-"*40)

# Empty list
empty_list = []
print(f"Empty list: {empty_list}")

# List with values
fruits = ["apple", "banana", "orange", "mango"]
print(f"Fruits: {fruits}")

# Mixed data types
mixed = [1, "hello", 3.14, True, None]
print(f"Mixed list: {mixed}")

# Using list() constructor
numbers = list(range(1, 6))
print(f"Numbers from range: {numbers}")

# List with repeated elements
zeros = [0] * 5
print(f"Repeated zeros: {zeros}")

# Nested lists
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(f"Matrix (2D list):")
for row in matrix:
    print(f"  {row}")

# 2. Accessing Elements
print("\n2. ACCESSING ELEMENTS:")
print("-"*40)

fruits = ["apple", "banana", "orange", "mango", "grape"]
print(f"Fruits: {fruits}")

# Positive indexing
print(f"First fruit: {fruits[0]}")
print(f"Third fruit: {fruits[2]}")
print(f"Last fruit: {fruits[-1]}")
print(f"Second last: {fruits[-2]}")

# Slicing
print(f"\nSlicing examples:")
print(f"First two: {fruits[0:2]}")
print(f"From index 2 to end: {fruits[2:]}")
print(f"Up to index 3: {fruits[:3]}")
print(f"Last two: {fruits[-2:]}")
print(f"Every other: {fruits[::2]}")
print(f"Reverse: {fruits[::-1]}")

# 3. Modifying Lists
print("\n3. MODIFYING LISTS:")
print("-"*40)

# Change element
fruits[1] = "blueberry"
print(f"After changing index 1: {fruits}")

# Add elements
fruits.append("kiwi")  # Add to end
print(f"After append: {fruits}")

fruits.insert(2, "strawberry")  # Insert at position
print(f"After insert at index 2: {fruits}")

# Extend list
more_fruits = ["peach", "pear"]
fruits.extend(more_fruits)
print(f"After extend: {fruits}")

# Remove elements
removed = fruits.pop()  # Remove last
print(f"Popped: {removed}, Remaining: {fruits}")

removed = fruits.pop(2)  # Remove at index
print(f"Popped index 2: {removed}, Remaining: {fruits}")

fruits.remove("apple")  # Remove by value
print(f"After removing 'apple': {fruits}")

# Clear list
test_list = [1, 2, 3]
print(f"Before clear: {test_list}")
test_list.clear()
print(f"After clear: {test_list}")

# 4. List Operations
print("\n4. LIST OPERATIONS:")
print("-"*40)

numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]
print(f"Original: {numbers}")

# Length
print(f"Length: {len(numbers)}")

# Count occurrences
print(f"Count of 1: {numbers.count(1)}")
print(f"Count of 5: {numbers.count(5)}")

# Find index
print(f"Index of 4: {numbers.index(4)}")
print(f"Index of 9: {numbers.index(9)}")

# Sort
numbers.sort()
print(f"Sorted ascending: {numbers}")

numbers.sort(reverse=True)
print(f"Sorted descending: {numbers}")

# Reverse
numbers.reverse()
print(f"Reversed: {numbers}")

# Min, Max, Sum
print(f"Min: {min(numbers)}")
print(f"Max: {max(numbers)}")
print(f"Sum: {sum(numbers)}")

# 5. List Comprehension
print("\n5. LIST COMPREHENSION:")
print("-"*40)

# Basic comprehension
squares = [x**2 for x in range(1, 6)]
print(f"Squares: {squares}")

# With condition
evens = [x for x in range(1, 11) if x % 2 == 0]
print(f"Even numbers: {evens}")

# Nested comprehension
matrix = [[i * j for j in range(1, 4)] for i in range(1, 4)]
print(f"Multiplication table:")
for row in matrix:
    print(f"  {row}")

# String manipulation
words = ["hello", "world", "python"]
upper_words = [word.upper() for word in words]
print(f"Uppercase: {upper_words}")

# With if-else
parity = ["even" if x % 2 == 0 else "odd" for x in range(1, 6)]
print(f"Parity: {parity}")

# Flatten a 2D list
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [num for row in matrix for num in row]
print(f"Flattened: {flat}")

# 6. List Methods Summary
print("\n6. LIST METHODS SUMMARY:")
print("-"*40)
methods = {
    "append(x)": "Add item to end",
    "extend(iterable)": "Add all items from iterable",
    "insert(i, x)": "Insert item at index",
    "remove(x)": "Remove first occurrence of x",
    "pop([i])": "Remove and return item at index",
    "clear()": "Remove all items",
    "index(x)": "Return index of first occurrence",
    "count(x)": "Count occurrences of x",
    "sort()": "Sort list in place",
    "reverse()": "Reverse list in place",
    "copy()": "Return shallow copy"
}

for method, desc in methods.items():
    print(f"  {method:15} - {desc}")

# 7. Practical Examples
print("\n7. PRACTICAL EXAMPLES:")
print("-"*40)

# Stack implementation
stack = []
stack.append(1)  # Push
stack.append(2)
stack.append(3)
print(f"Stack: {stack}")
print(f"Pop: {stack.pop()}")
print(f"Stack after pop: {stack}")

# Queue implementation (using collections.deque is better)
from collections import deque
queue = deque(["Alice", "Bob", "Charlie"])
print(f"Queue: {queue}")
queue.append("David")  # Enqueue
print(f"After enqueue: {queue}")
print(f"Dequeue: {queue.popleft()}")
print(f"After dequeue: {queue}")

# Remove duplicates while preserving order
items = [3, 1, 2, 1, 3, 4, 2, 5]
unique = []
for item in items:
    if item not in unique:
        unique.append(item)
print(f"Original: {items}")
print(f"Unique: {unique}")

# Grouping items
from collections import defaultdict
words = ["apple", "banana", "apricot", "berry", "cherry", "avocado"]
by_first = defaultdict(list)
for word in words:
    by_first[word[0]].append(word)
print("Words grouped by first letter:")
for letter, word_list in sorted(by_first.items()):
    print(f"  {letter}: {word_list}")

Output:

============================================================
LISTS IN PYTHON
============================================================

1. CREATING LISTS:
----------------------------------------
Empty list: []
Fruits: ['apple', 'banana', 'orange', 'mango']
Mixed list: [1, 'hello', 3.14, True, None]
Numbers from range: [1, 2, 3, 4, 5]
Repeated zeros: [0, 0, 0, 0, 0]
Matrix (2D list):
  [1, 2, 3]
  [4, 5, 6]
  [7, 8, 9]

2. ACCESSING ELEMENTS:
----------------------------------------
Fruits: ['apple', 'banana', 'orange', 'mango', 'grape']
First fruit: apple
Third fruit: orange
Last fruit: grape
Second last: mango

Slicing examples:
First two: ['apple', 'banana']
From index 2 to end: ['orange', 'mango', 'grape']
Up to index 3: ['apple', 'banana', 'orange']
Last two: ['mango', 'grape']
Every other: ['apple', 'orange', 'grape']
Reverse: ['grape', 'mango', 'orange', 'banana', 'apple']

3. MODIFYING LISTS:
----------------------------------------
After changing index 1: ['apple', 'blueberry', 'orange', 'mango', 'grape']
After append: ['apple', 'blueberry', 'orange', 'mango', 'grape', 'kiwi']
After insert at index 2: ['apple', 'blueberry', 'strawberry', 'orange', 'mango', 'grape', 'kiwi']
After extend: ['apple', 'blueberry', 'strawberry', 'orange', 'mango', 'grape', 'kiwi', 'peach', 'pear']
Popped: pear, Remaining: ['apple', 'blueberry', 'strawberry', 'orange', 'mango', 'grape', 'kiwi', 'peach']
Popped index 2: strawberry, Remaining: ['apple', 'blueberry', 'orange', 'mango', 'grape', 'kiwi', 'peach']
After removing 'apple': ['blueberry', 'orange', 'mango', 'grape', 'kiwi', 'peach']
Before clear: [1, 2, 3]
After clear: []

4. LIST OPERATIONS:
----------------------------------------
Original: [3, 1, 4, 1, 5, 9, 2, 6, 5]
Length: 9
Count of 1: 2
Count of 5: 2
Index of 4: 2
Index of 9: 5
Sorted ascending: [1, 1, 2, 3, 4, 5, 5, 6, 9]
Sorted descending: [9, 6, 5, 5, 4, 3, 2, 1, 1]
Reversed: [1, 1, 2, 3, 4, 5, 5, 6, 9]
Min: 1
Max: 9
Sum: 36

5. LIST COMPREHENSION:
----------------------------------------
Squares: [1, 4, 9, 16, 25]
Even numbers: [2, 4, 6, 8, 10]
Multiplication table:
  [1, 2, 3]
  [2, 4, 6]
  [3, 6, 9]
Uppercase: ['HELLO', 'WORLD', 'PYTHON']
Parity: ['odd', 'even', 'odd', 'even', 'odd']
Flattened: [1, 2, 3, 4, 5, 6, 7, 8, 9]

6. LIST METHODS SUMMARY:
----------------------------------------
  append(x)       - Add item to end
  extend(iterable)- Add all items from iterable
  insert(i, x)    - Insert item at index
  remove(x)       - Remove first occurrence of x
  pop([i])        - Remove and return item at index
  clear()         - Remove all items
  index(x)        - Return index of first occurrence
  count(x)        - Count occurrences of x
  sort()          - Sort list in place
  reverse()       - Reverse list in place
  copy()          - Return shallow copy

7. PRACTICAL EXAMPLES:
----------------------------------------
Stack: [1, 2, 3]
Pop: 3
Stack after pop: [1, 2]
Queue: deque(['Alice', 'Bob', 'Charlie'])
After enqueue: deque(['Alice', 'Bob', 'Charlie', 'David'])
Dequeue: Alice
After dequeue: deque(['Bob', 'Charlie', 'David'])
Original: [3, 1, 2, 1, 3, 4, 2, 5]
Unique: [3, 1, 2, 4, 5]
Words grouped by first letter:
  a: ['apple', 'apricot', 'avocado']
  b: ['banana', 'berry']
  c: ['cherry']
